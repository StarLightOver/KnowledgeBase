# M121 The MongoDB Aggregation Framework

## Особенности этапа $match

https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/

- $match = filter()
- Должен идти как можно раньше
- Может использовать индексы для оптимизации запросов (по этой причине должен идти как можно раньше)

## Особенности этапа $project

https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/

- $project = map()
- В отличии от $project в find имеет больше возможностей: выполнять любые рассчеты для полей, создавать новые поля в документе

## Особенности этапа $addFields

https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/

- $addFields = $project
- Добавляет новые поля в документы, при этом оставляя существующие

## Особенности этапа $geoNear

https://www.mongodb.com/docs/manual/reference/operator/aggregation/geoNear/

- Работает с геоданными
- Выводит документы в порядке от ближайшего к наиболее удаленному от указанной точки.

## Cursor-like этапы

- $limit
- $skip
- $count
- $sort

- При использовании этаап $sort есть ограничение по памяти в 100Мб. Его можно обойти используя allowDiskUse - теперь $sort может записывать временные файлы на диск, если требуется дополнительное место. Это актуально до mongo 6.0. Начиная с mongo 6.0 allowDiskUse=true по умолчанию

https://www.mongodb.com/docs/manual/reference/operator/aggregation/sort/#-sort-and-memory-restrictions

```javascript
aggregate(
    [{...}],
    {
        allowDiskUse: true
    })

```

## Особенности этапа $sample

https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/

- Рандомно выбирает значения из массива результатов

## Особенности этапа $group

https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/

- Группирует поля по заданному "_id"

```javascript
aggregate(
    [{
        $group:{
            _id: null,
            count: {$sum: 1}
        }
    }])
// =
.count()
```

## Особенности этапа $unwind

https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/

- Элемент массива в документе становится отдельным документов в итоговом результате.
- Следует из предыдущего - работает только с полями, которые являются массивами
- Есть две формы для этого этапа, дополнителньые поля можно посмотреть тут https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#preservenullandemptyarrays-and-includearrayindex
- Полезна, когда надо найти уникальные поля, содержащие некоторый набор значений. Можно сказать, что это distinct для поля-массива, где нам надо найти документы с таким же полем-массивом.
- Следует из предыдущего - на коллекциях с большими массивами/с большими документами могут быть проблемы  с производительностью.

## Особенности этапа $lookup

https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/

- $lookup = join
- Можно работать с коллекциями только в одной БД! Коллекция указывается в поле "from"
- Присоединение происходит по полям "localField" и "from"."foreignField"
- Результат записывает в поле указанное в "as"

## Особенности этапа $graphLookup

https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/

- Делает рекурсивный поиск в глубину


## Что такое Facets

Facet - грань, ограчить
Facets - границы, многогранный

"Фасетирование" или сегментирование - это набор инструментов для анализа данных (сегментирования), который позволяет пользователям изучать данные и их характеристики, а также применять различные фильтры.

Facet - какое то одно измерение или грань, по которому можно классифицировать данные

Например, есть каталог пользователей для LinkedIn.
Есть поиск, который ищет пользователей с словом "MongoDB" в профилях пользователей.
Результатов возвращает примерно 200 тысяч пользователей.
Можно рассмотреть фасет местоположения для дальнейшего сужения набора результатов в соответствии с определенными критериями.
Например, ограничить наборы результатов только пользователями в США, и получить набор результатов до 60 тысяч пользователей.

Фасеты в MongoDB реализованы с использованием агрегации и включают в себя несколько различных этапов.

## Single Facet Query на примере $sortByCount

- Группирует входящие документы на основе значения указанного выражения, затем вычисляет количество документов в каждой отдельной группе.
- _id - значение отдельной группировки, count - количество документов, принадлежащих к этой группе.
- Результат сортируется в порядке убывания.

## Manual Buckets на примере $bucket

- Классифицирует входящие документы по группам (сегментам, корзинам) и выводит документ для каждого группы 
- Выходной документ содержит поле _id, значение которого нижняя граница корзины.

```javascript
{
  $bucket: {
      groupBy: <expression>,
      boundaries: [ <lowerbound1>, <lowerbound2>, ... ],
      default: <literal>,
      output: {
         <output1>: { <$accumulator expression> },
         ...
         <outputN>: { <$accumulator expression> }
      }
   }
}
```

## Auto Buckets на примере $bucketAuto

- Позволяет классифицирует входящие документы по определенному количеству групп (сегментам, корзинам), на основе указанного выражения
- Границы корзин определяются автоматически в попытке равномерно распределить документы по указанному количеству
- Каждое корзина имеет _id, который определяет границы корзины. _id.min задает включающую нижнюю границу для корзины. _id.max задает верхнюю границу для корзины.
  ведро представлено в выходных данных в виде документа. Документ для каждой корзины содержит:

## Multiply Facets на примере $facet

- Такой этап в конвейере агрегации позволяет обрабатывает несколько конвейеров агрегации внутри себя. На входе используется один и тот же набора документов.
- Каждый внутренний конвейер на выходе сохраняется в отдельное поле, где его результаты - это массива документов.
- Входные документы передаются на этап $facet только один раз! Это позволяет выполнять различные агрегации над одним и тем же набором данных.








