# C# IEnumerable vs List and Array

Для начала надо понимать, какие есть интерфейсы, что они делают. Какие классы и какие интейрфейсы реализуют. В чем различие.

Очень наглядная картинка.

![](Images/IEnumerable-ICollection-IList.png)

Какие имеем интерфесы:

| # | Тип | Что понимаю под ним | Особенности |
|---|-----|---------------------|-------------|
| 1 | IEnumerable | Буквально то, что можно **перечислить**. То есть можно лишь итерироваться по каким то элементам вперед | MoveNext, Current |
| 2 | ICollection : IEnumerable | Дословно - это некоторая **коллекция**. Коллекции могут разными, но базово дают возможность к CRUD операциям с элементами внутри нее. Появляется возможность получить размер коллекции и установить признак изменяемости(IsReadOnly) | Add, Remove, Count, IsReadOnly |
| 3 | IList : ICollection | "Коллекция, которая обрела порядок." Появилась возможность обращаться к данным по индексу, а также выполнять сортировку | \[index\], Sort  |
| 4 | IReadOnlyCollection : IEnumerable | Неизменяемая коллекция, доступен только перечислитель и размер |  |
| 5 | IReadOnlyList : IReadOnlyCollection | Неизменяемая коллекция с опредленным порядком следования элементов. Доступено обращение по индексу |  |

Все классические структуры данных реализуют интерфейс ICollection и IReadOnlyCollection. List реализует IList и IReadOnlyList.

Что из этого имеем?

- Используя IEnumerable, мы даем доступ только для чтения, а List - нет.
- Структуры данных реализуют IEnumerable, но по факту представляет коллекцию в памяти.

Пример:

```c#
static void Main()
{
  var names = new List<string> {"sam", "alexia", "simon", "sumanth", "tony", "sam", "amr", "mark", "drew"};
  var moreThanFiveLetters = names.Where(w => w.Length > 5);
  names[0] = "benjamin";

  foreach (var name in moreThanFiveLetters)
  {
      Console.WriteLine(name);
  }
}
```

- Объект IEnumerable имеют метод для получения следующего элемента в коллекции. Ему не нужно, чтобы вся коллекция была в памяти. Объект не знает, сколько в нем элементов. Поэтому, например, когда мы вызываем foreach, мы просто продолжаем получать следующий элемент, пока они не закончатся.


- Выражения LINQ возвращают перечисление, и по умолчанию выражение выполняется, когда вы выполняете итерацию по нему с помощью foreach, но можно заставить его выполнить итерацию раньше, используя .ToList() или .ToArray()
- Если использовать .ToList() или .ToArray(), то компилятор сразу же преобразует результаты в заданную структуру
- Используя IEnumerable, мы даем компилятору возможность отложить работу на потом, и возможно, выполнить некоторую оптимизацию до непосредственного выполнения.

//

Если использовать тип интерфейса, такой как IEnumerable вместо IList, вы защищаете свой код от критических изменений.

Если использовать IEnumerable, то вызывающий ваш метод может предоставить любой объект, который реализует интерфейс IEnumerable.

Если использовать тип интерфейса, такой как IList, то больше рискуем нарушить изменения кода.

\\

Web API и HTTP

Если у вас одна часть приложения общается с другой частью по HTTP, например это разные слои сервисов или микросервисы, вы вероятно будете делать зарос из одного сервиса в другой через класс-клиент. И здесь, на секунду может показаться, что у вас есть выбор использовать что угодно, начиная с IEnumerable и заканчивая IList.

По HTTP коллекция уедет как JSON - сериализованный массив, вся целиком. И приедет как List. В данном случае нет никакого смысла отдавать\принимать что-то другое.

Указывая IEnumerable в response контроллера можно усложнить понимание кода.

# Ответы на вопросы

1. Что ты в итоге решил принимать в качестве параметров? Отдельно в случае внутреннего метода реализации или в публичных интерфейсах API.
   - Я бы локализовал изменения:
        - Если это метод класса, не часть интейрфейса, то уместно использовать IEnumerable, т.к. при любой необходимости разработчик может изменить это.
        - Если это метод интейрфеса, т.е. контракта, то тут следует исходить из места использования контракта и доменной модели. Важно ответить на вопрос что будет передаваться и с какой целью. Внутри доменов использовал использовал по необходимости, контракты для API придерживался бы Array/List
2. Что ты в итоге решил возвращать в качестве результата? Отдельно в случае внутреннего метода реализации или в публичных интерфейсах API.
   - Внутренний метод класса - IEnumerable/ICollection, т.к. есть 100% контроль за изменением.
   - Внешний метод (метод интерфейса) - IEnumerable/ICollection по ситуации, исходя из того для чего нужены эти данные внутри класса/вне класса. IReadOnlyCollection - если надо показать иммутабельность. HashSet - показать уникальность.
   - API - когда передаем объекты по сети, это некоторая последовательность, и когда они приходят, то это тоже цельная последдовательность. Полученые данные все равно бы приводил к одному из типов List/Array, а далее по необходимости.
3. Удобно ли свободный тип, возвращенный из метода, тут же начинать в коде превращать снова в массивы и списки для работы, чтобы не получать сотни ворнингов?
   - Зависит от требований, целей, задач используемого кода. Если заранее не известно как будет работать новый код с новыми данными, то лучше оставлять максимально обощенный интерфес - IReadOnlyCollection. Если уже понятно для чего и как что то будет использовать, то по требуемой ситуации.
4. Можешь ли ты полагаться на идеальную реализацию закрытого от тебя кода, что повторных итераций там не произойдет? Или же ты не сможешь этому доверять и несмотря на свободный интерфейс будешь "на всякий случай" туда кастовать и передавать массив? Как ты поступишь в случае работы с какой-то нашей библиотекой и в случае с публичной из нагета, ранее тебе неизвестной.
   - Нельзя никому не доверять. Лично я бы доверял своим бибилиотекам, больше чем с nuget. Но все равно не стал бы всегда пересобирать структуру. Это больше наводит на мысль, что тот кто кодит не понимает для чего он собирается ее использовать.
5. Как ты поступишь с точки зрения метрик. Ведь из-за отложенного выполнения иногда тебе придется кастовать объект здесь и сейчас перед возвращением значения из метода.
   - Обычно мы не снимаем метрики со всех хендлеров. У нас нет каких-то особых вычислительных хендлеров, поэтому зачастую мы снимаем метрики с точек получения данных, а это API, следовательно превращения последовательност ив упорядоченную структуру. 
6. Что ты в итоге решил использовать в публичных свойствах классов? Отдельно в случае внутреннего метода реализации или в публичных интерфейсах API.
   - Выше ответил.
7. Что ты считашь более важным: невозможность клиенту вызвать .Clear() по ошибке (злоумышленно по-прежнему можно), либо гарантированную защиту от повторного выполнения кода и неправильного сбора метрик по ошибке?
   - Не понял без контекста
8. Если ответы будут разными для разных случаев, то считаешь ли ты оправданным так усложнять стиль кода правилами?
   - Отсутствие правил = бездуманое написание кода? Я не предлагаю жестких правил, но хочу показать, что надо думать о ресурсах, даже если они всегда в изобилии.
9. \* Что если вместо общих понятий List<string> использовать более доменные, например ProductCollection, который работает с структурами Product, состоящими из string?
    - Если применить его повсеместно, то есть сделать структуру Product, на ее оснвое сделать ProductCollection, и т.д, то тогда отличная идея. В меньшем объеме выглядит немного странно, и добавит излишнюю сложность.


# Список литературы

(1) https://medium.com/@ben.k.muller/c-ienumerable-vs-list-and-array-9f099f157f4f

Статья (1) ссылается на интересные статьи:
(1.1) http://twistedoakstudios.com/blog/Post7694_achieving-exponential-slowdown-by-enumerating-twice
(1.2) https://stackoverflow.com/questions/3628425/ienumerable-vs-list-what-to-use-how-do-they-work/3628462#3628462
(1.3) https://www.claudiobernasconi.ch/2013/07/22/when-to-use-ienumerable-icollection-ilist-and-list/

Интересное обсуждение на reddit:
(2) https://www.reddit.com/r/csharp/comments/ubihmb/ienumerable_vs_list/

Статья от microsoft:
(3) https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/guidelines-for-collections?redirectedfrom=MSDN
(4) https://josipmisko.com/posts/c-sharp-ienumerable-vs-list
